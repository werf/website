---
title: Необходимо знать
permalink: nodejs/100_basic/40_must_haves.html
---

## Helm, релизы, вот это всё

[Чарты](https://helm.sh/docs/topics/charts/) — это набор файлов, описывающий связанный набор объектов Kubernetes. Когда чарт выкатывается в кластер в определённое окружение — создаётся _релиз_.

{% offtopic title="Что такое чарты и релизы?" %}
Могут быть сабчарты, чарты-ямлики описанные явно и их настройки в условном values.yaml

Верфь-чарт — то, что мы описываем в .helm ???
Он отличается от обычного чарта для хельма: например, он предлагает привязать имаджи, которые мы собираем с помощью специальных функций.

Релизы

, чтобы отслеживать изменения.

Релиз - это то состояние, что уже в кубернетесе.
У релиза есть состояния: выкачен, зафейлен, вот это всё
У чарта состояния нет, это шаблон.

https://ru.werf.io/documentation/advanced/helm/basics.html#%D1%80%D0%B5%D0%BB%D0%B8%D0%B7 — тут про релизы
{% endofftopic %}

При работе с релизами werf реализует механику [3-way merge](https://habr.com/ru/company/flant/blog/476646/), т.е. изменения, внесённые в кластер вручную также будут приведены к состоянию, описанному в git.

Релизы показывают **что конкретно в кластере установлено, в каком окружении** и в каком состоянии оно находится. Управляя релизами с помощью команд `werf helm <...>` вы можете управлять этим.

### Посмотреть, что установлено

Чтобы посмотреть список релизов, или найти как называется нужный вам релиз, воспользуйтесь CLI-командой [`werf helm list`](https://ru.werf.io/documentation/reference/cli/werf_helm_list.html).

### Удалить лишнее

Чтобы откатить релиз из списка — воспользуйтесь [`werf helm uninstall`](https://ru.werf.io/documentation/reference/cli/werf_helm_uninstall.html).

{% offtopic title="А как же команда werf dismiss?" %}
Команда [`werf dismiss`](https://ru.werf.io/documentation/reference/cli/werf_dismiss.html) также позволяет удалить приложение из Kubernetes. Однако, она требует наличия исходного кода приложения.
{% endofftopic %}

## Отладка установки

Зачастую возникают сложности при выкате релиза из-за ошибок, допущенных при написании чартов.

Отладить такие проблемы помогает команды [`werf render`](https://ru.werf.io/documentation/reference/cli/werf_render.html) и [`werf helm template`](https://ru.werf.io/documentation/reference/cli/werf_helm_template.html).

- `werf render` — проводит весь цикл сборки и генерации чартов и, вместо деплоя полученного релиза в kubernetes — выводит полученные чарты. Это "тяжёлая" операция, показывающая конечный результат со всеми реальными подставленными значениями.
- `werf helm template` — выполняет только генерацию чартов, а вместо некоторых значений подставляет заглушки. Эта команда работает очень быстро и помогает отлаживать сложные конструкции в helm (например, циклы или if-ы).

## Теггирование образов

Если процесс деплоя построен вручную, то приходится задавать строгие правила тегирования образов и соблюдать их. Однако, вы могли заметить, что в случае werf в чартах используется конструкция вида `{{ tuple "basicapp" . | werf_image}}`:

```yaml
      - name: basicapp
        command: ["node","/app/app.js"]
        image: {{ tuple "basicapp" . | werf_image}}
```

**Вам нет необходимости заботиться о правилах тегирования**: если что-то изменилось в коде — werf самостоятельно инцииирует пересборку нужного образа, загрузит полученные образ с нужными служебными тегами в Registry и подставит нужный образ в шаблоны. Для того, чтобы всё это корректно работало — werf хранит в registry метаданные и отслеживает содержимое файлов в git-репозитории.

{% offtopic title="Как это всё работает?" %}
Подробнее о том, как хранятся данные в Registry можно почитать [в документации werf](https://ru.werf.io/documentation/internals/stages_and_storage.html). Там подробнее написано, как устроен процесс сборки, как учитываются зависимости между стадиями сборки, а также — как устроено именование полученных образов.
{% endofftopic %}

Все данные могут храниться локально на хост-машине, либо в Docker Repo.

## Место в хранилище

Со временем в хранилище (локально или в Registry) может накопиться множество данных. Есть три команды, которые занимаются очисткой, но имеют разное предназначение: `werf cleanup`, `werf purge`, `werf host purge` — ниже рассмотрим их кратко, подробнее можно прочитать [в документации](https://ru.werf.io/documentation/advanced/cleanup.html).

### Регулярная очистка Registry

Для регулярной очистки есть безопасная команда [`werf cleanup`](https://ru.werf.io/documentation/reference/cli/werf_cleanup.html). Она не удаляет образы, которые используются в кластере. 

В главе "Работа с инфраструктурой" мы будем настраивать регулярную очистку registry по расписанию, используя возможности CI-системы.

### Удалить всё

Если есть необходимость освободить место на диске, удалив все образы, можно воспользоваться служебными командами

- [`werf host purge`](https://ru.werf.io/documentation/reference/cli/werf_host_purge.html) — очистка всего, что есть на хосте, где используется werf, без изменений в Registry
- [`werf purge`](https://ru.werf.io/documentation/reference/cli/werf_purge.html) — НЕ БЕЗОПАСНАЯ КОМАНДА, удаляет все образы, включая те, на которые завязаны приложения в кластере!

## Чуть-чуть рассказать про гитерминизм. Зачем он и как мы до этого докатились?


Проблема, которая лежит в основе – воспроизводимость. А точнее – гарантия воспроизводимости. И акцент тут именно на слове гарантия. Как гарантировать воспроизводимость?

Технически, когда CI-процесс прописан из говна и палок — часть ключевых настроек может браться хрен пойми откуда (с раннера, с каких-то динамических внешних ресурсов и т.п.).

А значит:

- нет никакой гарантии того, что проект будет воспроизводимым
- нет никакого простого способа понять, что нужно сделать, чтобы раскатать копию проекта

Хочется чтобы всё состояние хранилось в одном понятном месте и не было возможности обойти это.

Мы считаем, что то, что хранится - это то, что УЖЕ закоммиченно в гит, "прибито гвоздями".

Сейчас (werf 1.2):

Всё определяется только в werf/helm конфигах которые читаются только из git. Нельзя использовать переменные окружения и нельзя прочитать файл, который не комитнут. В том числе в go template, через функции Files.Get – ни в werf ни в helm в функциях File.Get (и аналогичных) не удастся прочитать файл, который НЕ комитнут.

- В следующей версии (1.3) мы отключим еще и все параметры --set и --values, оставим ТОЛЬКО параметр --env. То есть никакой внешний контекст в сборку передавать будет вообще нельзя. Но в 1.2 мы пока --set не трогаем.
- Мы понимаем, что есть случаи, когда надо въебать говна. Для этих случаев мы делаем отдельный конфиг (werf-gitermenism.yaml), в котором будет allow list вещей, которые можно херачить мимо git’а.

Такой подход дает:
- Гарантию воспроизводимости, потому что никакими действиями ты не можешь объебаться и сделать невоспроизводимо. Понятно, что есть файлик, который дает сделать нарушение. Но ты получаешь гарантию на всё, кроме того, для чего ты явно отключил.
- Простой способ понять, что нужно сделать чтобы раскатать копию проекта. Ведь все комитнуто в git, ну или есть файлик, в котором написано, что именно НЕ комитнуто.




Но надо ли всегда? Можно сделать git add чтобы они попали в отслеживаемые гитом файлы, а потом сделать wrf converge --dev
потом правишь код и запускаешь снова wrf converge --dev и всё

А можно сделать --follow и тогда пересборка будет запускаться автомагически от отслеживания файлов. Но как легко догадаться — тонкий лёд, время сборки длительное.


TODO:  https://flant.slack.com/archives/C1A6LT1T9/p1608311497206800?thread_ts=1608288797.189300&cid=C1A6LT1T9




<div id="go-forth-button">
    <go-forth url="40_optimize.html" label="Ускорение сборки" framework="{{ page.label_framework }}" ci="{{ page.label_ci }}" guide-code="{{ page.guide_code }}" base-url="{{ site.baseurl }}"></go-forth>
</div>
