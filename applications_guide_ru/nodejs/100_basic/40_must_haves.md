---
title: Необходимо знать
permalink: nodejs/100_basic/40_must_haves.html
---

## Helm, релизы, вот это всё

[Чарты](https://helm.sh/docs/topics/charts/) — это набор файлов, описывающий связанный набор объектов Kubernetes. Мы реализовали чарты в папке `.helm/templates`.

{% offtopic title="Подробнее о чартах?" %}
Могут быть сабчарты, чарты-ямлики описанные явно и их настройки в условном values.yaml


Верфь-чарт — то, что мы описываем в .helm ???
Он отличается от обычного чарта для хельма: например, он предлагает привязать имаджи, которые мы собираем с помощью специальных функций.
{% endofftopic %}

Когда чарт выкатывается в кластер в определённое окружение — создаётся _релиз_.

{% offtopic title="Подробнее о релизах?" %}
, чтобы отслеживать изменения.

Релиз - это то состояние, что уже в кубернетесе.
У релиза есть состояния: выкачен, зафейлен, вот это всё
У чарта состояния нет, это шаблон.

https://ru.werf.io/documentation/advanced/helm/basics.html#%D1%80%D0%B5%D0%BB%D0%B8%D0%B7 — тут про релизы
{% endofftopic %}

При работе с релизами werf реализует механику 3-way merge, т.е. изменения, внесённые в кластер вручную также будут приведены к состоянию, описанному в git.

{% offtopic title="Что за 3wm" %}
https://habr.com/ru/company/flant/blog/476646/

https://medium.com/flant-com/3-way-merge-patches-helm-werf-beb7eccecdfe
{% endofftopic %}

Релизы показывают ЧТО КОНКРЕТНО В КЛАСТЕРЕ УСТАНОВЛЕНО в каком окружении и позволяют управлять этим.

### Посмотреть, что установлено

Чтобы посмотреть список релизов воспользуйтесь CLI-командой [`werf helm list`](https://ru.werf.io/documentation/reference/cli/werf_helm_list.html)

? Зачем может понадобиться список релизов ? — в какие окружения выкачены приложения. Что уже выкачено.
Если пользоватеть не знает имя релиза, не знает объект как называется.

### Удалить лишнее

Чтобы откатить релиз из списка — воспользуйтесь [`werf helm uninstall`](https://ru.werf.io/documentation/reference/cli/werf_helm_uninstall.html).

?? В чём разница между werf dismiss и werf helm uninstall? — плюс минус одинаково. Но хельм анинсталл требует знать что конкретно ты грохаешь.
Если нет исходников например то это выручает.

## Отладка установки

Возможно надо поговорить про render и lint. И что мы к ним вернёмся позже.
Есть ещё werf helm template который подставляет плейсхолдеры и тупо рендерит хельм.
А werf render учитывает гитерменизм.


## Теггирование образов

Верфь сам всё тегирует, пишет какие-то хэш-суммы и делает так, чтобы они сами автоматом использовались в чартах. Тебе не надо самому проставлять теги в чартах.

{% offtopic title="Как это всё работает?" %}
https://ru.werf.io/documentation/internals/stages_and_storage.html — надо кратко и ёмко описать, почему стоит читать статью

Если хочется понять, что там хранится, почему такие странные имена.

И тут надо привести примеры странных имён

{% endofftopic %}

Все данные могут храниться локально на хост-машине, либо в Docker Repo.

## Место в хранилище

Со временем в хранилище может накопиться множество данных. Чтобы очистить неиспользуемые данные есть несколько подходов:

- очистка по политикам (`werf cleanup`) — безопасная процедура, рекомендованная для использования. Она не удаляет те образы, которые используются в кластере. Это обслуживающая история.
- ручная очистка (`werf purge`) — удаляет все образы
- очистка всего что есть на хосте, на котором используется werf, без изменений в Registry (`werf host purge`) — чтобы всё удалить и вообще

Подробнее в доке: https://ru.werf.io/documentation/advanced/cleanup.html

И подробнее будет это рассматривать в следующих главах.



## Чуть-чуть рассказать про гитерминизм. Зачем он и как мы до этого докатились?


Проблема, которая лежит в основе – воспроизводимость. А точнее – гарантия воспроизводимости. И акцент тут именно на слове гарантия. Как гарантировать воспроизводимость?

Технически, когда CI-процесс прописан из говна и палок — часть ключевых настроек может браться хрен пойми откуда (с раннера, с каких-то динамических внешних ресурсов и т.п.).

А значит:

- нет никакой гарантии того, что проект будет воспроизводимым
- нет никакого простого способа понять, что нужно сделать, чтобы раскатать копию проекта

Хочется чтобы всё состояние хранилось в одном понятном месте и не было возможности обойти это.

Мы считаем, что то, что хранится - это то, что УЖЕ закоммиченно в гит, "прибито гвоздями".

Сейчас (werf 1.2):

Всё определяется только в werf/helm конфигах которые читаются только из git. Нельзя использовать переменные окружения и нельзя прочитать файл, который не комитнут. В том числе в go template, через функции Files.Get – ни в werf ни в helm в функциях File.Get (и аналогичных) не удастся прочитать файл, который НЕ комитнут.

- В следующей версии (1.3) мы отключим еще и все параметры --set и --values, оставим ТОЛЬКО параметр --env. То есть никакой внешний контекст в сборку передавать будет вообще нельзя. Но в 1.2 мы пока --set не трогаем.
- Мы понимаем, что есть случаи, когда надо въебать говна. Для этих случаев мы делаем отдельный конфиг (werf-gitermenism.yaml), в котором будет allow list вещей, которые можно херачить мимо git’а.

Такой подход дает:
- Гарантию воспроизводимости, потому что никакими действиями ты не можешь объебаться и сделать невоспроизводимо. Понятно, что есть файлик, который дает сделать нарушение. Но ты получаешь гарантию на всё, кроме того, для чего ты явно отключил.
- Простой способ понять, что нужно сделать чтобы раскатать копию проекта. Ведь все комитнуто в git, ну или есть файлик, в котором написано, что именно НЕ комитнуто.




Но надо ли всегда? Можно сделать git add чтобы они попали в отслеживаемые гитом файлы, а потом сделать wrf converge --dev
потом правишь код и запускаешь снова wrf converge --dev и всё

А можно сделать --follow и тогда пересборка будет запускаться автомагически от отслеживания файлов. Но как легко догадаться — тонкий лёд, время сборки длительное.


TODO:  https://flant.slack.com/archives/C1A6LT1T9/p1608311497206800?thread_ts=1608288797.189300&cid=C1A6LT1T9




<div id="go-forth-button">
    <go-forth url="40_optimize.html" label="Ускорение сборки" framework="{{ page.label_framework }}" ci="{{ page.label_ci }}" guide-code="{{ page.guide_code }}" base-url="{{ site.baseurl }}"></go-forth>
</div>
