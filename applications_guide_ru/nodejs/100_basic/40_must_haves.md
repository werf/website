---
title: Необходимо знать
permalink: nodejs/100_basic/40_must_haves.html
layout: "wip"
---

Чтобы вам было комфортно и вы чувствовали себя уверенно при использовании werf, вам нужно знать несколько особенностей и возможностей:

- Прежде всего это **принципы работы с исходным кодом и понятие гитерменизма**, обеспечивающие гарантию воспроизводимости приложения на любом стенде;
- Затем, **устройство тегирования образов** и надо ли беспокоиться о тегах, чтобы организовать сборку и деплой (нет, не надо);
- При выкате на стенды вам предстоит столкнуться с понятием **релизов**, а также процессом **отладки** оных;
- Спустя некоторое время, вследствие доработок приложения и регулярных релизов, вы можете столкнуться с проблемой **места в хранилище образов** и необходимостью делать очистку образов. В werf есть механизмы, сильно облегчающие эту задачу.

Все эти вопросы подробнее рассмотрены далее.

## Работа с исходным кодом и гитерминизм

Зачастую часть настроек, влияющих на конфигурацию выкаченного приложения, формируется на основании «внешних» данных: файлов на runner'е, динамических показателей, берущихся с внешних ресурсов, и т.д. Это напрямую влияет на невозможность **гарантировать воспроизводимость** состояния приложения.

{% offtopic title="А зачем нам воспроизводимость?" %}
Если мы можем в любой момент быстро воспроизвести состояние приложения, нам проще заниматься **отладкой**, проще **развернуть копию проекта** (как для разработки, так и для организации нового стенда) и мы можем увереннее опираться на результаты тестирования на том или ином стенде (т.к. у нас меньше скрытых параметров, влияющих на состояние).

Воспроизводимость фундаментально необходима для реализации [Infrastructure as code](https://en.wikipedia.org/wiki/Infrastructure_as_code) и immutable infrastructure.
{% endofftopic %}

Чтобы **гарантировать** воспроизводимость, werf по умолчанию считает, что существует только то состояние, которое закоммичено в Git. Таким образом, Git является достаточным источником сведений о приложении.

{% offtopic title="Как конкретно это реализуется?" %}
Всё определяется только в конфигах werf/Helm, которые читаются только из Git. Нельзя использовать переменные окружения и нельзя прочитать файл, который не коммитнут.

Функции `Files.Get` в werf и Helm дают читать только те файлы, что коммитнуты.

В werf 1.3 планируется также отключить CLI-параметры `--set` и `--values`, реализовав механизм жёсткого определения и валидации допустимых внешних параметров (OpenAPI), чтобы полностью обезопасить использование внешнего контекста.
{% endofftopic %}

Однако мы понимаем, что в процессе разработки делать коммит на каждое изменение кода крайне неудобно. Поэтому для удобной разработки в werf есть специализированные режим `--dev`. Кроме этого в некоторых ситуациях сборка должна зависеть от внешнего контекста, для этих редких случаев есть возможность конфигурировать механики гитерменизма с помощью файла `werf-giterminism.yaml`.


### werf-giterminism.yaml

С помощью этого конфигурационного файла можно указывать, какие ограничения в текущей конфигурации будут сняты (например, использование незакоммиченных файлов, монтирование директорий и файлов на этапе сборки, проброску переменных окружения и т.п.). Подробнее о правилах конфигурирования [читайте в документации](https://werf.io/v1.2-alpha/documentation/advanced/configuration/giterminism.html#werf-giterminismyaml).


### dev-режим

Если запустить `converge` (или другую команду — например, `render`) с CLI-параметром `--dev`:

```shell
werf converge --repo registry.example.com/werf-guided-nodejs --dev
```

… то собираться и деплоиться будут не только закоммиченные, но и **отслеживаемые файлы** (т.е. добавленные с помощью `git add`).


{% offtopic title="И зачем мне каждый раз вызывать git add?" %}

как вы знаете верфь читает из гита в обычном режиме (чтобы гарантировать воспроизводимость)
технических ограничений читать напрямую из ФС нет, но для того, чтобы не поймать баги на разности на чтении из гита и чтении из ФС верфь даже в дев режиме читает только из гита. это создаёт дополнительную защиту и предсказуемость поведения, обеспечивает гарантию, что конечная сборка будет работать так же, как дев сборка.

дополнительно, благодаря этому подходу, вы никогда не забудете добавить файлы в коммит. 

{% endofftopic %}

### follow-режим

Кроме dev-режима может быть полезен **follow-режим**. Если вы запустите `converge` (или другую команду — например, `run` или `compose up`) с CLI-параметром `--follow`:

```shell
werf converge --repo registry.example.com/werf-guided-nodejs --follow
```

… то при каждом коммите в Git команда будет автоматически перезапускаться.

Если совместить `--folow` и `--dev`, то команда будет перезапускаться при выполнении пользователем команды `git add`.

## Тегирование образов

Если бы вы строили процесс деплоя без werf, вручную, то вам бы пришлось задавать строгие правила тегирования образов и соблюдать их (поверьте, это [очень непросто](https://www.youtube.com/watch?v=oh4N2wBJCc8)). Однако вы могли заметить, что в случае werf в чартах используется конструкция вида {% raw %}`image: {{ .Values.werf.image.basicapp }}`{% endraw %}:

{% raw %}
```yaml
      - name: basicapp
        command: ["node","/app/app.js"]
        image: {{ .Values.werf.image.basicapp }}
```
{% endraw %}

**Вам нет необходимости заботиться о правилах тегирования**: если что-то изменилось в коде — werf самостоятельно инициирует пересборку необходимого образа, загрузит полученный образ со служебными тегами в registry и подставит этот образ в шаблоны. Для того, чтобы всё это корректно работало, werf хранит в registry метаданные и отслеживает содержимое файлов в Git-репозитории.

{% offtopic title="Как это всё работает?" %}
если кратко, верфь расчитывает контрольную сумму файлов, добавляемых в образы и на основании этого генерирует теги для образа. однако он это делает таким образом, чтобы несколько сборок собирающихся параллельно (в том числе на разных серверах) не конфликтовали (используется подход на основе идеи mvcc и optimistic locking).

Подробнее о том, как хранятся данные в registry, можно почитать [в документации werf](https://ru.werf.io/documentation/internals/stages_and_storage.html). Там написано, как устроен процесс сборки, как учитываются зависимости между стадиями сборки, а также — как устроено именование полученных образов.
{% endofftopic %}

## Helm, релизы, вот это всё

[Чарты](https://helm.sh/docs/topics/charts/) — это набор файлов, описывающий связанный набор объектов Kubernetes. Когда чарт выкатывается в кластер в определённое окружение — создаётся _релиз_.

{% offtopic title="Где почитать подробнее" %}
В [документации werf](https://ru.werf.io/documentation/advanced/helm/basics.html#%D1%80%D0%B5%D0%BB%D0%B8%D0%B7) есть подробное описание того, как устроена работа с релизами, хранение и именование их.
{% endofftopic %}

При работе с релизами helm реализует механику [3-way merge](https://helm.sh/docs/faq/#improved-upgrade-strategy-3-way-strategic-merge-patches), т.е. изменения, внесённые в кластер вручную, и противоречащие тому, что описано в Git будут приведены к последнему (внесённые вручную изменения, не противоречащие git, остаются не под контролем helm и werf).

Верфь управляет релизами самостоятельно, но если вы хотите залезть в глубины, вы можете использовать команды `werf helm <...>`.

### Посмотреть, что установлено

Релизы показывают, **что конкретно в кластере установлено, в каком окружении** и в каком состоянии оно находится.

Чтобы посмотреть список релизов или найти, как называется нужный вам релиз, воспользуйтесь CLI-командой [`werf helm list -A`](https://ru.werf.io/documentation/reference/cli/werf_helm_list.html).

### Удалить лишнее

Чтобы удалить приложение, воспользуйтесь werf dismiss или [`werf helm uninstall`](https://ru.werf.io/documentation/reference/cli/werf_helm_uninstall.html).

{% offtopic title="А как же команда werf dismiss?" %}
Команда [`werf dismiss`](https://ru.werf.io/documentation/reference/cli/werf_dismiss.html) также позволяет удалить приложение из Kubernetes. Однако, она требует наличия исходного кода приложения, что может быть неудобно за пределами CI-системы.
{% endofftopic %}

## Отладка установки

Зачастую возникают сложности при выкате релиза из-за ошибок, допущенных при написании чартов. Отладить такие проблемы помогает команда [`werf render`](https://ru.werf.io/documentation/reference/cli/werf_render.html).

`werf render` — проводит весь цикл сборки и генерации чартов и, вместо деплоя полученного релиза в kubernetes — выводит полученные чарты. Это "тяжёлая" операция, показывающая конечный результат со всеми реальными подставленными значениями.

_Обратите внимание, что как и все другие команды `werf render` работает только с коммитнутыми в git файлами, но поддерживает `--dev` режим._

## Место в хранилище

Со временем в хранилище (локально или в registry) может накопиться множество данных. Есть три команды, которые занимаются очисткой, но имеют разное предназначение: `werf cleanup`, `werf purge`, `werf host purge` — ниже рассмотрим их кратко, а подробнее можно прочитать [в документации](https://ru.werf.io/documentation/advanced/cleanup.html).

### Регулярная очистка Registry

Для регулярной очистки есть безопасная команда [`werf cleanup`](https://ru.werf.io/documentation/reference/cli/werf_cleanup.html). Она на основании git истории, содержимого registry и состояния кластера с помощью продвинутого алгоритма безопасно удаляет образы, которые более не требуются.

В главе «Работа с инфраструктурой» мы будем настраивать регулярную очистку registry по расписанию, используя возможности CI-системы.

### Удалить всё

Если есть необходимость освободить место на диске, удалив все образы и другие данные, можно воспользоваться служебными командами:

- [`werf host purge`](https://ru.werf.io/documentation/reference/cli/werf_host_purge.html) — очистка всего, что есть на хосте, где используется werf, без изменений в registry;
- [`werf purge`](https://ru.werf.io/documentation/reference/cli/werf_purge.html) — НЕ БЕЗОПАСНАЯ КОМАНДА, которая удаляет все образы, включая те, на которые завязаны приложения в кластере!
