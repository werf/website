---
title: Необходимо знать
permalink: nodejs/100_basic/40_must_haves.html
---

## Helm, релизы, вот это всё

[Чарты](https://helm.sh/docs/topics/charts/) — это набор файлов, описывающий связанный набор объектов Kubernetes. Когда чарт выкатывается в кластер в определённое окружение — создаётся _релиз_.

{% offtopic title="Где почитать подробнее" %}
В [документации werf](https://ru.werf.io/documentation/advanced/helm/basics.html#%D1%80%D0%B5%D0%BB%D0%B8%D0%B7) есть подробное описание того, как устроена работа с релизами, хранение и именование их.
{% endofftopic %}

При работе с релизами werf реализует механику [3-way merge](https://habr.com/ru/company/flant/blog/476646/), т.е. изменения, внесённые в кластер вручную, также будут приведены к состоянию, описанному в Git.

Релизы показывают, **что конкретно в кластере установлено, в каком окружении** и в каком состоянии оно находится. Оперируя релизами с помощью команд `werf helm <...>`, вы можете управлять этим.

### Посмотреть, что установлено

Чтобы посмотреть список релизов или найти, как называется нужный вам релиз, воспользуйтесь CLI-командой [`werf helm list`](https://ru.werf.io/documentation/reference/cli/werf_helm_list.html).

### Удалить лишнее

Чтобы откатить релиз из списка, воспользуйтесь [`werf helm uninstall`](https://ru.werf.io/documentation/reference/cli/werf_helm_uninstall.html).

{% offtopic title="А как же команда werf dismiss?" %}
Команда [`werf dismiss`](https://ru.werf.io/documentation/reference/cli/werf_dismiss.html) также позволяет удалить приложение из Kubernetes. Однако она требует наличия исходного кода приложения.
{% endofftopic %}

## Отладка установки

Зачастую возникают сложности при выкате релиза из-за ошибок, допущенных при написании чартов.

Отладить такие проблемы помогают команды [`werf render`](https://ru.werf.io/documentation/reference/cli/werf_render.html) и [`werf helm template`](https://ru.werf.io/documentation/reference/cli/werf_helm_template.html).

- `werf render` — проводит весь цикл сборки и генерации чартов и, вместо деплоя полученного релиза в Kubernetes, выводит полученные чарты. Это «тяжёлая» операция, показывающая конечный результат со всеми реальными подставленными значениями.
- `werf helm template` — выполняет только генерацию чартов, а вместо некоторых значений подставляет заглушки. Эта команда работает очень быстро и помогает отлаживать сложные конструкции в Helm (например, циклы или if'ы).

## Тегирование образов

Если процесс деплоя построен вручную, то приходится задавать строгие правила тегирования образов и соблюдать их. Однако вы могли заметить, что в случае werf в чартах используется конструкция вида `{{ tuple "basicapp" . | werf_image}}`:

```yaml
      - name: basicapp
        command: ["node","/app/app.js"]
        image: {{ tuple "basicapp" . | werf_image}}
```

**Вам нет необходимости заботиться о правилах тегирования**: если что-то изменилось в коде — werf самостоятельно инициирует пересборку нужного образа, загрузит полученный образ с нужными служебными тегами в registry и подставит нужный образ в шаблоны. Для того, чтобы всё это корректно работало, werf хранит в registry метаданные и отслеживает содержимое файлов в Git-репозитории.

{% offtopic title="Как это всё работает?" %}
Подробнее о том, как хранятся данные в registry, можно почитать [в документации werf](https://ru.werf.io/documentation/internals/stages_and_storage.html). Там подробнее написано, как устроен процесс сборки, как учитываются зависимости между стадиями сборки, а также — как устроено именование полученных образов.
{% endofftopic %}

Все данные могут храниться локально на хост-машине либо в Docker Repo.

## Место в хранилище

Со временем в хранилище (локально или в registry) может накопиться множество данных. Есть три команды, которые занимаются очисткой, но имеют разное предназначение: `werf cleanup`, `werf purge`, `werf host purge` — ниже рассмотрим их кратко, а подробнее можно прочитать [в документации](https://ru.werf.io/documentation/advanced/cleanup.html).

### Регулярная очистка Registry

Для регулярной очистки есть безопасная команда [`werf cleanup`](https://ru.werf.io/documentation/reference/cli/werf_cleanup.html). Она не удаляет образы, которые используются в кластере. 

В главе «Работа с инфраструктурой» мы будем настраивать регулярную очистку registry по расписанию, используя возможности CI-системы.

### Удалить всё

Если есть необходимость освободить место на диске, удалив все образы, можно воспользоваться служебными командами:

- [`werf host purge`](https://ru.werf.io/documentation/reference/cli/werf_host_purge.html) — очистка всего, что есть на хосте, где используется werf, без изменений в registry;
- [`werf purge`](https://ru.werf.io/documentation/reference/cli/werf_purge.html) — НЕ БЕЗОПАСНАЯ КОМАНДА, которая удаляет все образы, включая те, на которые завязаны приложения в кластере!

## Гитерминизм

Зачастую часть настроек, влияющих на конфигурацию выкаченного приложения, формируется на основании «внешних» данных: файлов на runner'е, динамических показателей, берущихся с внешних ресурсов, и т.д. Это напрямую влияет на невозможность **гарантировать воспроизводимость** состояния приложения.

{% offtopic title="А зачем нам воспроизводимость?" %}
Если мы можем в любой момент быстро воспроизвести состояние приложения, нам проще заниматься **отладкой**, проще **развернуть копию проекта** (как для разработки, так и для организации нового стенда) и мы можем увереннее опираться на результаты тестирования на том или ином стенде (т.к. у нас меньше скрытых параметров, влияющих на состояние).
{% endofftopic %}

Чтобы **гарантировать** воспроизводимость, werf по умолчанию считает, что существует только то состояние, которое закоммичено в Git. Таким образом, Git является достаточным источником сведений о приложении.

{% offtopic title="Как конкретно это реализуется?" %}
Всё определяется только в конфигах werf/Helm, которые читаются только из Git. Нельзя использовать переменные окружения и нельзя прочитать файл, который не коммитнут.

Функции `Files.Get` в werf и Helm дают читать только те файлы, что коммитнуты.

В werf 1.3 будут также отключены CLI-параметры `--set` и `--values` и останется только параметр `--env`, чтобы никакой внешний контекст нельзя было передать в сборку.
{% endofftopic %}

Однако мы понимаем, что в процессе разработки делать коммит на каждое изменение кода крайне неудобно. Поэтому для удобной разработки в werf есть специализированные режимы `--dev` и `--follow`.

### dev-режим

Если запустить `converge` (или другую команду — например, `render`) с CLI-параметром `--dev`:

```shell
werf converge --repo registry.example.com/werf-guided-nodejs --dev
```

… то собираться и деплоиться будут не только закоммиченные, но и **отслеживаемые файлы** (т.е. добавленные с помощью `git add`).

### follow-режим

Если запустить `converge` (или другую команду — например, `render`) с CLI-параметром `--follow`:

```shell
werf converge --repo registry.example.com/werf-guided-nodejs --follow
```

… то при каждом коммите в Git команда будет автоматически перезапускаться.

Если совместить `--folow` и `--dev`, то команда будет перезапускаться при выполнении пользователем команды `git add`.

<div id="go-forth-button">
    <go-forth url="40_optimize.html" label="Ускорение сборки" framework="{{ page.label_framework }}" ci="{{ page.label_ci }}" guide-code="{{ page.guide_code }}" base-url="{{ site.baseurl }}"></go-forth>
</div>
