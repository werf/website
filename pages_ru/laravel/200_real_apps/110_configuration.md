---
title: Управление конфигурацией приложения
permalink: laravel/200_real_apps/110_configuration.html
layout: wip
---

Использование werf предполагает описание полной конфигурации сборки и выката приложения в git-репозитории приложения вместе с его кодом. Инфраструктура описывается как код и к ней применимы те же методы разработки, что и для самого приложения. Чтобы внести изменение в инфраструктуру мы правим код и применяем новую версию через утилиту werf. Такой подход называют infrastructure-as-code (IaC).

Чтобы эффективно и удобно описывать конфигурацию приложения werf предоставляет следующее:
- шаблонизация werf.yaml;
- шаблонизация .helm/templates;
- конфигурация входных данных для шаблонов helm через values-файлы;
- хранение секретных данных в репозитории приложения;
- мощный инструмент для обеспечения воспроизводимости конфигураций — гитерминизм;
- возможность определять разные окружения одного приложения с помощью параметра env;
- возможность выносить отдельные самодостаточные компоненты в так называемые chart'ы;
- возможность выносить переиспользуемые шаблоны в так называемые library chart'ы;
- использование нескольких образов в werf.yaml для разных целей.

Далее в главе будут подробно рассмотрены все указанные пункты с примерами.

<cut>
<!-- TODO: Надо сделать шаг подготовка сворачиваемым и по умолчанию свёрнутым -->

## Подготовка

Возьмём за основу web-приложение из раздела "первые шаги". Состояние директории `rails-app` должно соответствовать шагу `examples/rails/019_fixup_consistency`:

```
git clone https://github.com/werf/werf-guides
cp -r werf-guides/examples/rails/019_fixup_consistency rails-app
cd rails-app
git init
git add .
git commit -m "initial"
```

</cut>

## 0. Что-то про типы и виды конфигурации приложения в Kubernetes

Приложение конфигурится через переменные окружения, ConfgiMaps и Secrets.

Переменные окружения:
- взять из CM
    - большие штуки
- взять из секрета
    - пароль от базы
- выставить явно в .helm/templates

описать когда что использовать

## 1. Шаблонизируем описание образов и манифестов Kubernetes

werf как и другие решения связанные с Kubernetes написан на Golang и использует [gotemplates](https://golang.org/pkg/text/template/) для шаблонизации на уровне генерирования текста конфигов — yaml-файлов.

Допустим, мы хотим использовать и стабильную версию ruby и новейшую одновременно для нашего rails приложения. Хотим чтобы часть реплик в production работало на старой версии ruby, а часть на новой. Для начала нам надо будет собрать отдельные образы для каждой версии ruby.

TODO: выставим состояние приложения 1100_configuration_image_per_ruby

### Добавим образы в werf.yaml

- werf.yaml используется для описания образов приложения.
- werf.yaml позволяет описать сразу несколько образов приложения.

Мы будем генерировать набор образов в werf.yaml, подставляя базовый образ через параметр [dockerfile build arg](https://docs.docker.com/engine/reference/builder/#arg) `RUBY_VERSION`.

Для начала превратим наш Dockerfile в шаблон добавив build argument `RUBY_VERSION`:

snippetcut_example Dockerfile // TODO

Сгенерируем 2 отдельных образа в `werf.yaml` для версий ruby `2.7.3` — назовём образ `basicapp-stable`, и ruby `3.0.1` — назовём образ `basicapp-experimental`:

snippetcut_example werf.yaml image_per_ruby // TODO

Проверим в результирующий рендер конфига:

```shell
werf config render --dev
```

Результат должен быть следующим:

```yaml
...
---
image: basicapp-stable-ruby
dockerfile: Dockerfile
args:
  RUBY_VERSION: 2.7.3
---
image: basicapp-experimental-ruby
dockerfile: Dockerfile
args:
  RUBY_VERSION: 3.0.1
...
```

### Используем образы в Helm

Все файлы в .helm/templates являются golang-шаблонами, результатом рендера которых является набор yaml-манифестов, разделённых через `---`.

Ранее у нас использовался один Deployment `basicapp`. Теперь, используя шаблонизацию, сделано так, что в файле `.helm/templates/deployment.yaml` Deployment генерируется 2 Deployment'а — один по-прежнему называется `basicapp`, но использует образ `basicapp-stable-ruby`,  второй называется `basicapp-experimental` и он использует образ `basicapp-experimental-ruby`.

snippetcut_example .helm/templates/deployment.yaml

Обратим внимание на использование конструкции `index .Values.werf.image .ImageName` — этот синтаксис позволяет достать из маппинга `.Values.werf.image` значение по ключу, записанному в переменную `.ImageName`. Также такой синтаксис может быть использован в случае использования символа `-` в названии образа: дело в том, что go-шаблоны не позволяют написать `.Values.werf.image.basicapp-stable` из-за символа `-`, поэтому в таком случае тоже используется функция `index` для получения значения по произвольному ключу в общей форме.

Обратим внимание, что оба Deployment'а `basicapp` и `basicapp-experimental` используют `label.app=basicapp` для создаваемых подов. Из этого следует, что Service с именем `basicapp` будет выбирать и балансировать нагрузку на Pod'ы, создаваемые Deployment `basicapp` и `basicapp-experimental`:

snippetcut_example .helm/templates/service.yaml

### Выкатываем

TODO проверить что оно работает и написать команду

## 2. Конфигурируем входные данные для Helm и werf.yaml

При описании конфигурации удобно разделять входные данные для шаблонизации и сами шаблоны конфигурации. Почему:
- Данные могут быть собраны в одном месте, а не размазаны по всем шаблонам в папке .helm/templates.
- Данные предоставляют "рычаги управления", по сути это интерфейс для изменения поведения шаблонов.
- Шаблоны при этом реализуют лишь алгоритмы обработки этих данных и генерируют манифесты.

Примеры таких данных:
- Для собираемых образов через werf.yaml:
    - Имя базового образа.
    - Версия языка программирования и каких-то системных библиотек встроенных в образ.
    - Версия сборочного кеша, при изменении которой инициируется полная пересборка образов.
    - И т.п.
- Для манифестов объявляемых в .helm/templates:
    - Базовый url приложения.
    - Url внешнего сервиса, используемый в приложении.
    - Количество реплик для разных компонентов (backend, frontend и т.п.).
    - Лимиты memory и cpu для разных компонентов (backend, frontend, mysql, redis, sidekiq, и т.п.).
    - Имя пользователя, пароль, адрес и имя для внешней базы данных, которая задеплоена вне приложения.
    - И т.п.

Обратим внимание, что как для werf.yaml, так и для .helm/templates часто возникает необходимость передать секретные данные, такие как пароли, токены для внешних git репозиториев с зависимостями приложения, 

### Гитерминизм

- Базовое требование werf: все входные данные для конфигурации werf.yaml должны храниться в git-репозитории проекта.
- werf построен так, что:
    - Верифицирует все используемые файлы в момент билда/деплоя на наличие некоммитнутых в гит изменений, и читает все файлы только из текущего гит-коммита.
    - Не позволяет читать переменные окружения во время рендеринга werf.yaml.
    - А также не позволяет использовать директивы stapel-сборщика fromLatest, git.branch и прочие.
    - Подробнее про гитерминизм: https://ru.werf.io/documentation/v1.2/advanced/giterminism.html
- Данным строгим правилам werf следует всегда по умолчанию.
    - В некоторых ситуациях от правил можно отходить.
    - Есть конфигурационный файл werf-giterminism.yaml, который как раз позволяет описывать те места, где мы отходим от гитерминизма.
        - Однако рекомендуется как можно меньше использовать werf-giterminism.yaml для построения более простых, надёжных и воспроивзодимых конфигураций.

В данной статье нам понадобится настраивать werf-giterminism.yaml далее, а пока просто примем к сведению.

### Конфигурируем werf.yaml

`werf.yaml` является центральным конфигом werf и точкой входа, поэтому отдельного файла для входных данных шаблонизации `werf.yaml` werf не предоставляет. Обычно такие данные описываются прямо в начале файла `werf.yaml`:

snippetcut_example 1101 werf.yaml

Рассмотрим что тут происходит.

Во-первых версии ruby для stable и experimental образов из предыдущего пункта главы заданы в начале файла через ключи `.StableRubyVersion` и `.ExperimentalRubyVersion`.

Также туда добавлено глобальное значение `.CacheVersion=1`: изменяя цифру вручную пользователь получает возможность правильным способом инициировать пересборку всех образов Правильным в данном случае потому, что эта цифра зафиксирована в werf.yaml и хранится в git-репозитории. Этот способ даёт гитерминированность и воспроизводимость, в отличие от такого способа сброса кеша, когда мы вручную удаляем ранее созданные образы и слои и вызываем пересборку — в этом случае повторный вызов сборки, например, для старого коммита выдаст новый кеш, что является нарушением принципа воспроизводимости кеша.

Помимо прочего наше приложение теперь требует передачи секретного токена в сборочный процесс, так как в Gemfile былa добавленa библиотека из приватного репозитория на гитхабе. Токен передаётся через переменную окружения `GITHUB_TOKEN`.

Использование переменной окружения `GITHUB_TOKEN` является отступлением от принципов [гитерминизма](#гитерминизм). По умолчанию werf не позволяет использовать переменные окружения. Следующий конфиг `werf-giterminism.yaml` разрешает использование этой переменной:

snippetcut_example 1101 werf-giterminism.yaml

Обратим внимание, что глобальные переменные `$.CacheVersion` и `$.GithubToken`, заданные в начале файла `werf.yaml`, передаются в сборку нашего Dockerfile в качестве build arguments `CACHE_VERSION` и `GITHUB_TOKEN` соответственно:

snippetcut_example 1101 Dockerfile

`GITHUB_TOKEN` тут попадает в параметр `BUNDLE_GITHUB__COM` для `bundle install`. Далее этот токен будет автоматически использован для скачивание зависимостей приложения, указанных в `Gemfile` через url `github.com`:

snippetcut_example 1101 Gemfile

Обратим внимание на использование конструкции `$_ := set . "KEY" "VALUE"` в `werf.yaml`. Данная конструкция создаёт в корневом контексте (что такое контекст шаблона можно почитать ТУТ) новый ключ `KEY` и прописывает в него значение `VALUE`. Использование `$_ := ` в данном случае обязательно, иначе возвращаемое значение функции `set` попадёт в рендер результирующего `werf.yaml`, если же результирующее значение запомнить в переменной, то данная конструкция не повлияет на рендер (просто особенность go-templates, о которой надо знать).

### Конфигурируем Helm

Встроенный в werf Helm предоставляет такой механизм конфигурирования шаблонов как [values](https://ru.werf.io/documentation/v1.2/advanced/helm/configuration/values.html). Values — это произвольная структура данных, которая доступна для использования в шаблонах Helm.

Values могут быть описаны через yaml-файлы, либо переданы через CLI с помощью параметров `--set`, `--set-string`, `--set-file`. По умолчанию используется файл `.helm/values.yaml`, также можно передать дополнительные файлы через параметр `--values`.

werf также предоставляет средства для передачи секретных данных в шаблоны — через так называемые [secret values](https://ru.werf.io/documentation/v1.2/advanced/helm/configuration/values.html#%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B5-%D1%81%D0%B5%D0%BA%D1%80%D0%B5%D1%82%D1%8B). По умочанию используется файл `.helm/secret-values.yaml`, также можно передать дополнительные файлы через параметр `--secret-values`.

werf в соответствии с принципами гитерминизма вводит требование, чтобы все values файлы и secret-values файлы, а также файлы, переданные конструкцией `--set-file` обязательно были коммитнуты в git-репозиторий проекта.

Все values и secret-values файлы, а также параметры переданные через `--set-*` совмещаются в одну единую структуру данных, к которой можно обращаться из шаблонов Helm с помощью конструкции `.Values`.

В нашем примере воспользуемся стандартными файлами `.helm/values.yaml` и `.helm/secret-values.yaml`.

snippetcut_examle 1101 .helm/values.yaml

replicas
url
mysql username & password (SECRETS!)
лимиты cpu & memory
также для примера передадим параметры для подключения к внешнему сервису (см. главу про S3 TODO).

- В нашем случае был использован такой 128-битный ключ `WERF_SECRET_KEY=f1305914ac3394cac6d95225e6231d3e` для симметричного шифрования алгоритмом AES-128.
- Использовать секретные данные в процессе деплоя, или расшифровать их для простмотра, или отредактировать их можно только зная этот ключ симметричного шифрования.
    - **ВАЖНО!** Данный ключ никогда не хранится в git-репозитории проекта и всегда передаётся извне через переменную окружения.
        - Чаще всего это секретная переменная окружения в CI/CD системе (подробнее см. раздел TODO).

Посмотрим что за секретные данные у нас зашифрованы, для этого откроем режим редактивания `.helm/secret-values.yaml`:

```shell
WERF_SECRET_KEY=f1305914ac3394cac6d95225e6231d3e werf helm secret values edit .helm/secret-values.yaml
```

— должен открыться стандартный системный редактор, в котором будет расшифрованное содержимое данного файла, после сохранения и закрытия редактора werf зашифрует обновлённые данные и сохранит в `.helm/secret-values.yaml`. (Если редактор не открывается, следует попробовать явно установить переменную окружения `EDITOR=...`, например `EDITOR=vi WERF_SECRET_KEY=... werf helm secret values edit ...`).

werf поддерживает и другие способы расшифровки и зашифровки секретных переменных. Подробнее о них и в целом о секретах можно узнать в статьях документации:
- https://ru.werf.io/documentation/v1.2/advanced/helm/configuration/values.html#%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B5-%D1%81%D0%B5%D0%BA%D1%80%D0%B5%D1%82%D1%8B
- https://ru.werf.io/documentation/v1.2/advanced/helm/configuration/secrets.html

Обратим внимание что структура данного secret-values файла совпадает со структурой файла .helm/values.yaml, лишь за тем отличием, что в данном файле передаются секретные ключи, а в обычном values файле не секретные. Итоговые `.Values` в шаблонах будут совмещены автоматически.

...

## 3. Кастомизируем конфигурацию под окружение

В werf имеется такой параметр, как `--env` (или переменная окружения `WERF_ENV`) — параметр окружения. Любая высокоуровневая команда werf принимает опциональный параметр окружения. С помощью данного параметра можно рендерить разную версию конфигов как для сборки образов, так и для деплоя в Kubernetes.

В качестве значения передаётся произвольная строка, например: `production`, `dev`, `stage` или `test`. Переданный параметр будет доступен в go-шаблонах и его можно будет использовать в условных конструкциях, чтобы генерировать разные манифесты для разных окружений, использовать 

и подобных местах.

Завязать на параметр RAILS_ENV.
Разный набор ресурсов для разных окружений.
Разное количество реплик.

backend:
  replicas: 5

Разный набор гемов для разных окружений. Передаём env через dockerfile-build-args.

Пару слов о том, что можно передать разные values-файлы для разных окружений. Такая схема тоже допустима и реализуется путём явной передачи параметров `--values` и `--secret-values` из разных окружений CI/CD системы, откуда происходит вызов werf (см. подробнее статью ...).

## 4. Выделим общие шаблоны

DRY

## 5. Подключаем внешние чарты
