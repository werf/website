---
title: Необходимо знать
permalink: golang/100_basic/40_must_haves.html
---

Чтобы вам было комфортно и вы чувствовали себя уверенно при использовании werf, нужно знать несколько особенностей и возможностей:

- Во-первых, понимать **принципы работы с исходным кодом и что такое гитерминизм** (giterminism) — они обеспечивают надежность и гарантию воспроизводимости, а также унифицируют все процессы.
- Во-вторых, иметь представление об **устройстве тегирования образов** и том, надо ли беспокоиться о тегах, чтобы организовать сборку и деплой (нет, не надо).
- При выкате на стенды вам предстоит столкнуться с понятием **релизов**, а также с процессом их **отладки**.
- Рано или поздно, как следствие доработок приложения и регулярных релизов, вы можете столкнуться с проблемой **места в хранилище образов** и необходимостью делать очистку образов.

Все эти вопросы подробнее рассмотрены далее.

## Работа с исходным кодом и гитерминизм

Зачастую часть настроек, влияющих на конфигурацию выкаченного приложения, формируется на основании «внешних» данных: окружения, в котором выполняется сборка и выкат, предустановленных переменных окружения и сгенерированных файлов, использования внешних ресурсов и т.д. Это напрямую влияет на невозможность **гарантировать воспроизводимость** состояния приложения.

{% offtopic title="А зачем нам воспроизводимость?" %}
Если в любой момент можно быстро воспроизвести состояние приложения, то проще заниматься **отладкой**, проще **развернуть копию проекта** (как для разработки, так и для организации нового стенда) и мы можем увереннее опираться на результаты тестирования на том или ином стенде (т.к. у нас меньше скрытых параметров, влияющих на состояние).

Воспроизводимость фундаментально необходима для реализации подхода [infrastructure as code](https://en.wikipedia.org/wiki/Infrastructure_as_code) и immutable infrastructure.
{% endofftopic %}

Чтобы **гарантировать** воспроизводимость, werf следует принципам гитерминизма, детерминируя работу с проектом файлами текущего git-состояния (HEAD коммита). По умолчанию werf не позволяет использовать некоммитнутые файлы в конфигурации и сборочном контексте собираемых образов, а также исключает функционал, потенциально имеющий внешние зависимости.

Мы настоятельно рекомендуем следовать этому подходу, но при необходимости можно явно ослабить ограничения гитерминизма, а также включить функционал, требующий осмысленного использования, с конфигурацией [werf-giterminism.yaml]({{ site.docsurl }}/documentation/reference/werf_giterminism_yaml.html).

При отладке и разработке, изменение файлов проекта может доставлять неудобства за счёт необходимости создания промежуточных коммитов. В этих случаях рекомендуется работать в [режиме разработчика](#dev-режим).

Подробнее про гитерминизм можно прочитать в документации [werf]({{ site.docsurl }}/documentation/advanced/giterminism.html).

### dev-режим

Режим разработчика активируется опцией `--dev` или соответствующей переменной окружения `WERF_DEV`. Поддерживается два режима работы, которые регулируются опцией `--dev-mode` (по умолчанию _simple_):

- _simple_: для работы с состоянием worktree git-репозитория проекта;
- _strict_: для работы с [состоянием index](http://shafiul.github.io/gitbook/1_the_git_index.html), в git-репозитории проекта.

Стоит отметить, что новые файлы (_untracked_) должны всегда добавляться в index вручную (единоразовая операция, которая выполняется командой `git add` для каждого вновь добавленного файла).

### follow-режим

Режим follow позволяет перезапускать команду при изменении состояния git:

- команда перезапускается при создании нового коммита;
- совместно с [dev-режимом](#dev-режим) (`--dev`) дополнительно отслеживается состояние index git-репозитория, для перезапуска команды достаточно добавить новые изменения в index (`git add`).

Режим активируется опцией `--follow` или соответствующей переменной окружения `WERF_FOLLOW`.

## Тегирование образов

Если бы вы строили процесс деплоя без werf, вручную, то вам бы пришлось задавать строгие правила тегирования образов и соблюдать их (поверьте, это [очень непросто](https://www.youtube.com/watch?v=oh4N2wBJCc8)). Однако вы могли заметить, что в случае werf в чартах используется конструкция вида {% raw %}`image: {{ .Values.werf.image.basicapp }}`{% endraw %}:

{% raw %}
```yaml
      - name: basicapp
        command: ["/app/demoapp"]
        image: {{ .Values.werf.image.basicapp }}
```
{% endraw %}

**Вам нет необходимости заботиться о правилах тегирования**: если что-то изменилось в коде — werf самостоятельно инициирует пересборку необходимого образа, загрузит полученный образ со служебными тегами в registry и подставит этот образ в шаблоны. Для того, чтобы всё это корректно работало, werf хранит в registry метаданные и отслеживает содержимое файлов в Git-репозитории.

{% offtopic title="Как это всё работает?" %}
werf реализует тегирование, которое называется content-based (т.е. основанное на содержимом): образы меняются и выкатываются автоматически, если меняется состояние контента в Git. И, что важно, образы не меняются от коммита к коммиту и не происходит лишних перевыкатов, если состояние контента в GIt не поменялось.

При организации деплоя без использования werf зачастую приходится формализовать принципы, по которым именуются образы в registry. В нашем случае нет необходимости думать об этом: werf берёт организацию тегирования на себя.

Если кратко, werf рассчитывает контрольную сумму файлов, добавляемых в образы, и на основании этого генерирует теги для образа. Однако, он это делает таким образом, чтобы несколько сборок, собирающихся параллельно (в том числе на разных серверах), не конфликтовали. Для этого используется подход, основанный на идеях [MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control) и [optimistic locking](https://en.wikipedia.org/wiki/Optimistic_concurrency_control).

Подробнее о том, как хранятся данные в registry, можно почитать [в документации werf]({{ site.docsurl }}/documentation/internals/stages_and_storage.html). Там написано, как устроен процесс сборки, как учитываются зависимости между стадиями сборки, а также — как устроено именование полученных образов.
{% endofftopic %}

## Helm, релизы, вот это всё

[Helm-чарт](https://helm.sh/docs/topics/charts/) — это набор файлов, описывающий связанный набор объектов Kubernetes. Когда чарт выкатывается в кластер в определённое окружение — создаётся _релиз_.

{% offtopic title="Где почитать подробнее" %}
В [документации werf]({{ site.docsurl }}/documentation/v1.2/advanced/helm/releases/release.html) есть подробное описание того, как устроена работа с релизами, их хранение и именование.
{% endofftopic %}

При работе с релизами Helm реализует механику [3-way merge](https://helm.sh/docs/faq/#improved-upgrade-strategy-3-way-strategic-merge-patches), т.е. изменения, внесённые в кластер вручную и противоречащие тому, что описано в Git, будут приведены к последнему. Обратите внимание, что внесённые вручную изменения, не противоречащие Git, остаются не под контролем Helm и werf.

werf управляет релизами самостоятельно, но если вы хотите залезть в глубины, можно использовать команды `werf helm <...>`.

### Посмотреть, что установлено

Релизы показывают, **что конкретно в кластере установлено, в каком окружении** и в каком состоянии оно находится.

Чтобы посмотреть список релизов или найти, как называется нужный вам релиз, воспользуйтесь CLI-командой [`werf helm list -A`]({{ site.docsurl }}/documentation/reference/cli/werf_helm_list.html).

### Удалить лишнее

Чтобы удалить релиз приложения из Kubernetes, воспользуйтесь [`werf dismiss`]({{ site.docsurl }}/documentation/reference/cli/werf_dismiss.html).

## Отладка установки

Зачастую возникают сложности при выкате релиза из-за ошибок, допущенных при написании чартов. Отладить такие проблемы помогает команда [`werf render`]({{ site.docsurl }}/documentation/reference/cli/werf_render.html).

`werf render` проводит весь цикл сборки и генерации чартов и, вместо деплоя полученного релиза в Kubernetes, выводит полученные чарты. Это «тяжёлая» операция, показывающая конечный результат со всеми реальными подставленными значениями.

_Обратите внимание, что, как и все другие команды, `werf render` работает только с коммитнутыми в Git файлами, но поддерживает режим `--dev`._

## Место в хранилище

Со временем в хранилище (локально или в registry) может накопиться множество данных. Есть три команды, которые занимаются очисткой, но имеют разное предназначение: `werf cleanup`, `werf purge`, `werf host purge` — ниже рассмотрим их кратко (подробнее можно прочитать [в документации]({{ site.docsurl }}/documentation/advanced/cleanup.html)).

### Регулярная очистка registry

Для регулярной очистки есть безопасная команда [`werf cleanup`]({{ site.docsurl }}/documentation/reference/cli/werf_cleanup.html). Она безопасно удаляет образы, которые более не требуются, с помощью продвинутого алгоритма, учитывающего Git-историю, содержимое registry и состояние кластера.

В главе «Работа с инфраструктурой» мы будем настраивать регулярную очистку registry по расписанию, используя возможности CI-системы.

### Удалить всё

Если есть необходимость освободить место на диске, удалив все образы и другие данные, можно воспользоваться служебными командами:

- [`werf host purge`]({{ site.docsurl }}/documentation/reference/cli/werf_host_purge.html) — очистка всего, что есть на хосте, где используется werf, без изменений в registry;
- [`werf purge`]({{ site.docsurl }}/documentation/reference/cli/werf_purge.html) — НЕБЕЗОПАСНАЯ КОМАНДА, которая удаляет все образы!
