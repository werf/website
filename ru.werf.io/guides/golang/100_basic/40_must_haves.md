---
title: Необходимо знать
permalink: golang/100_basic/40_must_haves.html
---

Чтобы вам было комфортно и вы чувствовали себя уверенно при использовании werf, нужно знать несколько особенностей и возможностей:

- Во-первых, понимать **принципы работы с исходным кодом и что такое гитерминизм** (giterminism) — они обеспечивают гарантию воспроизводимости приложения на любом стенде.
- Во-вторых, иметь представление об **устройстве тегирования образов** и том, надо ли беспокоиться о тегах, чтобы организовать сборку и деплой (нет, не надо).
- При выкате на стенды вам предстоит столкнуться с понятием **релизов**, а также с процессом **отладки** оных.
- Спустя некоторое время, как следствие доработок приложения и регулярных релизов, вы можете столкнуться с проблемой **места в хранилище образов** и необходимостью делать очистку образов. В werf есть механизмы, сильно облегчающие эту задачу.

Все эти вопросы подробнее рассмотрены далее.

## Работа с исходным кодом и гитерминизм

Зачастую часть настроек, влияющих на конфигурацию выкаченного приложения, формируется на основании «внешних» данных: файлов на runner'е, динамических показателей, берущихся с внешних ресурсов, и т.д. Это напрямую влияет на невозможность **гарантировать воспроизводимость** состояния приложения.

{% offtopic title="А зачем нам воспроизводимость?" %}
Если мы можем в любой момент быстро воспроизвести состояние приложения, нам проще заниматься **отладкой**, проще **развернуть копию проекта** (как для разработки, так и для организации нового стенда) и мы можем увереннее опираться на результаты тестирования на том или ином стенде (т.к. у нас меньше скрытых параметров, влияющих на состояние).

Воспроизводимость фундаментально необходима для реализации подхода [infrastructure as code](https://en.wikipedia.org/wiki/Infrastructure_as_code) и immutable infrastructure.
{% endofftopic %}

Чтобы **гарантировать** воспроизводимость, werf по умолчанию считает, что существует только то состояние, которое закоммичено в Git. Таким образом, Git является достаточным источником сведений о приложении.

{% offtopic title="Как конкретно это реализуется?" %}
Всё определяется только в конфигах werf/Helm, которые читаются только из Git. Нельзя использовать переменные окружения и нельзя прочитать файл, который не коммитнут в Git.

Функции `Files.Get` в werf и Helm дают читать только те файлы, что коммитнуты.

В werf 1.3 планируется также отключить CLI-параметры `--set` и `--values`, реализовав механизм жёсткого определения и валидации допустимых внешних параметров (OpenAPI), чтобы полностью обезопасить использование внешнего контекста.
{% endofftopic %}

Однако мы понимаем, что в процессе разработки делать коммит на каждое изменение кода крайне неудобно. Поэтому для удобной разработки в werf есть специализированный режим `--dev`. Кроме этого, в некоторых ситуациях сборка должна зависеть от внешнего контекста: для таких редких случаев есть возможность конфигурировать настройки гитерминизма с помощью файла `werf-giterminism.yaml`.

### werf-giterminism.yaml

С помощью этого конфигурационного файла можно указывать, какие ограничения в текущей конфигурации будут сняты (например, использование незакоммиченных файлов, монтирование директорий и файлов на этапе сборки, проброс переменных окружения и т.п.). Подробнее о правилах конфигурирования [читайте в документации](https://ru.werf.io/v1.2-alpha/documentation/advanced/configuration/giterminism.html#werf-giterminismyaml).


### dev-режим

Если запустить `converge` (или другую команду — например, `render`) с CLI-параметром `--dev`:

```shell
werf converge --repo registry.example.com/werf-guided-golang --dev
```

… то собираться и деплоиться будут не только закоммиченные, но и **отслеживаемые файлы** (т.е. добавленные с помощью `git add`).


{% offtopic title="И зачем мне каждый раз вызывать git add?" %}
Как вы уже знаете, чтобы гарантировать воспроизводимость, werf в «обычном» режиме читает файлы только из Git.

Это сделано не из-за технических ограничений (ничто не мешает читать файлы напрямую из ФС), но для того, чтобы ликвидировать неопределённость. Чтобы не спровоцировать баги на разности в чтении файлов из Git и файловой системы, даже в dev-режиме werf читает файлы только из Git.

Таким образом, создаётся дополнительный слой защиты и предсказуемости поведения, а вы никогда не забудете добавить файлы в commit и всегда получите в конечной сборке то же, что и при локальной разработке.
{% endofftopic %}

### follow-режим

Кроме dev-режима может быть полезен **follow-режим**. Если вы запустите `converge` (или другую команду — например, `run` или `compose up`) с CLI-параметром `--follow`:

```shell
werf converge --repo registry.example.com/werf-guided-golang --follow
```

… то при каждом коммите в Git команда будет автоматически перезапускаться.

Если совместить `--folow` и `--dev`, то команда будет перезапускаться при выполнении пользователем `git add`.

## Тегирование образов

Если бы вы строили процесс деплоя без werf, вручную, то вам бы пришлось задавать строгие правила тегирования образов и соблюдать их (поверьте, это [очень непросто](https://www.youtube.com/watch?v=oh4N2wBJCc8)). Однако вы могли заметить, что в случае werf в чартах используется конструкция вида {% raw %}`image: {{ .Values.werf.image.basicapp }}`{% endraw %}:

{% raw %}
```yaml
      - name: basicapp
        command: ["/app/demoapp"]
        image: {{ .Values.werf.image.basicapp }}
```
{% endraw %}

**Вам нет необходимости заботиться о правилах тегирования**: если что-то изменилось в коде — werf самостоятельно инициирует пересборку необходимого образа, загрузит полученный образ со служебными тегами в registry и подставит этот образ в шаблоны. Для того, чтобы всё это корректно работало, werf хранит в registry метаданные и отслеживает содержимое файлов в Git-репозитории.

{% offtopic title="Как это всё работает?" %}
Если кратко, werf рассчитывает контрольную сумму файлов, добавляемых в образы, и на основании этого генерирует теги для образа. Однако, он это делает таким образом, чтобы несколько сборок, собирающихся параллельно (в том числе на разных серверах), не конфликтовали. Для этого используется подход, основанный на идеях [MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control) и [optimistic locking](https://en.wikipedia.org/wiki/Optimistic_concurrency_control).

Подробнее о том, как хранятся данные в registry, можно почитать [в документации werf](https://ru.werf.io/documentation/internals/stages_and_storage.html). Там написано, как устроен процесс сборки, как учитываются зависимости между стадиями сборки, а также — как устроено именование полученных образов.
{% endofftopic %}

## Helm, релизы, вот это всё

[Helm-чарт](https://helm.sh/docs/topics/charts/) — это набор файлов, описывающий связанный набор объектов Kubernetes. Когда чарт выкатывается в кластер в определённое окружение — создаётся _релиз_.

{% offtopic title="Где почитать подробнее" %}
В [документации werf](https://ru.werf.io/documentation/advanced/helm/basics.html#%D1%80%D0%B5%D0%BB%D0%B8%D0%B7) есть подробное описание того, как устроена работа с релизами, их хранение и именование.
{% endofftopic %}

При работе с релизами Helm реализует механику [3-way merge](https://helm.sh/docs/faq/#improved-upgrade-strategy-3-way-strategic-merge-patches), т.е. изменения, внесённые в кластер вручную и противоречащие тому, что описано в Git, будут приведены к последнему. Обратите вниманипе, что внесённые вручную изменения, не противоречащие Git, остаются не под контролем Helm и werf.

werf управляет релизами самостоятельно, но если вы хотите залезть в глубины, можно использовать команды `werf helm <...>`.

### Посмотреть, что установлено

Релизы показывают, **что конкретно в кластере установлено, в каком окружении** и в каком состоянии оно находится.

Чтобы посмотреть список релизов или найти, как называется нужный вам релиз, воспользуйтесь CLI-командой [`werf helm list -A`](https://ru.werf.io/documentation/reference/cli/werf_helm_list.html).

### Удалить лишнее

Чтобы удалить приложение, воспользуйтесь [`werf helm uninstall`](https://ru.werf.io/documentation/reference/cli/werf_helm_uninstall.html).

{% offtopic title="А как же команда werf dismiss?" %}
Команда [`werf dismiss`](https://ru.werf.io/documentation/reference/cli/werf_dismiss.html) также позволяет удалить приложение из Kubernetes. Однако она требует наличия исходного кода приложения, что может быть неудобно за пределами CI-системы.
{% endofftopic %}

## Отладка установки

Зачастую возникают сложности при выкате релиза из-за ошибок, допущенных при написании чартов. Отладить такие проблемы помогает команда [`werf render`](https://ru.werf.io/documentation/reference/cli/werf_render.html).

`werf render` проводит весь цикл сборки и генерации чартов и, вместо деплоя полученного релиза в Kubernetes, выводит полученные чарты. Это «тяжёлая» операция, показывающая конечный результат со всеми реальными подставленными значениями.

_Обратите внимание, что, как и все другие команды, `werf render` работает только с коммитнутыми в Git файлами, но поддерживает режим `--dev`._

## Место в хранилище

Со временем в хранилище (локально или в registry) может накопиться множество данных. Есть три команды, которые занимаются очисткой, но имеют разное предназначение: `werf cleanup`, `werf purge`, `werf host purge` — ниже рассмотрим их кратко (подробнее можно прочитать [в документации](https://ru.werf.io/documentation/advanced/cleanup.html)).

### Регулярная очистка registry

Для регулярной очистки есть безопасная команда [`werf cleanup`](https://ru.werf.io/documentation/reference/cli/werf_cleanup.html). Она безопасно удаляет образы, которые более не требуются, с помощью продвинутого алгоритма, учитывающего Git-историю, содержимое registry и состояние кластера.

В главе «Работа с инфраструктурой» мы будем настраивать регулярную очистку registry по расписанию, используя возможности CI-системы.

### Удалить всё

Если есть необходимость освободить место на диске, удалив все образы и другие данные, можно воспользоваться служебными командами:

- [`werf host purge`](https://ru.werf.io/documentation/reference/cli/werf_host_purge.html) — очистка всего, что есть на хосте, где используется werf, без изменений в registry;
- [`werf purge`](https://ru.werf.io/documentation/reference/cli/werf_purge.html) — НЕ БЕЗОПАСНАЯ КОМАНДА, которая удаляет все образы, включая те, на которые завязаны приложения в кластере!
