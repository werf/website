---
title: Working with files
permalink: rails/200_real_apps/050_s3.html
examples_initial: examples/rails/040_db
examples: examples/rails/050_s3
base_url: https://github.com/werf/werf-guides/blob/master/
description: |
  In this chapter, we will implement the ability to download and upload files in the application. In addition, we will discuss some aspects of working with files in Kubernetes and provide a practical example of using S3-compatible storage.
---

## Storing files

Containers running in Kubernetes are often created and deleted automatically, e.g., because of Deployment updates. This means that application files cannot be stored on the container file system since those files will be:
* available to a single container/application replica rather than all of them;
* deleted when the container is killed.

Thus, it makes sense to store in the containers only the data you can afford to lose.

> _By the way, you can set the container file system to read-only. This will improve security and prevent the application from storing data locally._

But what if you need to keep some data? You can use standalone databases for that. For example, NoSQL databases such as object storages are often used for storing regular files. Object stores that provide an Amazon S3-compatible API are especially popular.

Below, we will show you how to store files in S3-compatible storage instead of a local file system. This way, your application can remain stateless and avoid some issues when working in Kubernetes.

## Enabling Active Storage

We have to enable the Active Storage component to use the object storage.

Thus, we introduced a basic Active Storage configuration in our application using a new skeleton Rails app generated by the following command (note that the `--skip-active-storage` flag was removed):
```shell
rails new --database mysql --skip-keeps --skip-action-mailer --skip-action-mailbox --skip-action-text --skip-active-job --skip-action-cable --skip-sprockets --skip-spring --skip-listen --skip-turbolinks --skip-jbuilder --skip-test --skip-system-test --skip-bootsnap .
```

Here is the list of changes made to our application:
1. Adding the `aws-sdk-s3` gem to [Gemfile]({{ page.base_url | append: page.examples | append: "/Gemfile" }}).
1. Adding the `rails-activestorage` package to [package.json]({{ page.base_url | append: page.examples | append: "/package.json" }}).
1. Enabling `active_storage/engine` in [config/application.rb]({{ page.base_url | append: page.examples | append: "/config/application.rb" }}) and initializing Active Storage in [packs/application.js]({{ page.base_url | append: page.examples | append: "/app/javascript/packs/application.js" }}).
1. Generating a [migration]({{ page.base_url | append: page.examples | append: "/db/migrate/20210830170827_create_active_storage_tables.active_storage.rb" }}) that creates tables required for Active Storage.
1. Creating the [config/storage.yml]({{ page.base_url | append: page.examples | append: "/config/storage.yml" }}) configuration file.

## Adding `/upload` and `/download` endpoints to the application

Let's add two new endpoints, `/upload` (to upload a file to the S3-compatible object storage) and `/download` (to download a file from the S3-compatible object storage), to see how uploading and downloading works.

Let's add a new controller and model:
{% include snippetcut_example path="app/controllers/s3_file_controller.rb" syntax="rb" examples=page.examples %}
{% include snippetcut_example path="app/models/s3_file.rb" syntax="rb" examples=page.examples %}

Now it is time to add new paths to the routes:
{% include snippetcut_example path="config/routes.rb" syntax="rb" snippet="s3" examples=page.examples %}

Don’t forget about the migration to create tables:
{% include snippetcut_example path="db/migrate/20210830171006_create_s3_files.rb" syntax="rb" examples=page.examples %}

Now let’s generate and save new [db/schema.rb]({{ page.base_url | append: page.examples | append: "/db/schema.rb" }}).

New endpoints, `/upload` and `/download`, have been added. Next, we need to configure them to work with the storage.

## Deploying and configuring MinIO

For illustrative purposes, we will use the [MinIO](https://min.io/) S3-compatible object storage. However, you can use any other S3-compatible storage (such as Amazon S3) instead.

> _If the different type of S3 storage is used, you do not need to create MinIO’s StatefulSet and Job as described below. However, all further steps remain unchanged._

Let's add a StatefulSet for MinIO:
{% include snippetcut_example path=".helm/templates/storage.yaml" syntax="yaml" examples=page.examples %}

The next step is to create a Job for setting up MinIO:
{% include snippetcut_example path=".helm/templates/job-setup-minio.yaml" syntax="yaml" examples=page.examples %}

Add the configuration for connecting to MinIO:
{% include snippetcut_example path="config/storage.yml" syntax="yaml" examples=page.examples %}

Activate the configured MinIO storage to store files:
{% include snippetcut_example path="config/environments/production.rb" syntax="rb" snippet="storage" examples=page.examples %}

MinIO is now ready to be deployed while our application is configured to store files with it.

## Testing the storage

First, let’s deploy our application:
```shell
werf converge --repo <DOCKER HUB USERNAME>/werf-guide-app
```

You should see the following output:
```shell
...
┌ ⛵ image backend
│ ┌ Building stage backend/dockerfile
│ │ backend/dockerfile  Sending build context to Docker daemon  338.4kB
│ │ backend/dockerfile  Step 1/25 : FROM ruby:2.7 as base
│ │ backend/dockerfile   ---> 1faa5f2f8ca3
...
│ │ backend/dockerfile  Step 25/25 : LABEL werf-version=v1.2.13+fix12
│ │ backend/dockerfile   ---> Running in 14e4091f77b4
│ │ backend/dockerfile  Removing intermediate container 14e4091f77b4
│ │ backend/dockerfile   ---> a13f82df04f3
│ │ backend/dockerfile  Successfully built a13f82df04f3
│ │ backend/dockerfile  Successfully tagged 5ee7a784-4b47-402c-8fe1-b15af1418df0:latest
│ │ ┌ Store stage into .../werf-guide-app
│ │ └ Store stage into .../werf-guide-app (13.79 seconds)
│ ├ Info
│ │      name: .../werf-guide-app:2fafb795aa5ea01de13a6095eeca262552b79dddfedc887b1781bc5f-1630413036132
│ │        id: a13f82df04f3
│ │   created: 2021-08-31 15:30:35 +0300 MSK
│ │      size: 366.3 MiB
│ └ Building stage backend/dockerfile (23.83 seconds)
└ ⛵ image backend (30.97 seconds)

┌ ⛵ image frontend
│ ┌ Building stage frontend/dockerfile
│ │ frontend/dockerfile  Sending build context to Docker daemon  338.4kB
│ │ frontend/dockerfile  Step 1/29 : FROM ruby:2.7 as base
│ │ frontend/dockerfile   ---> 1faa5f2f8ca3
...
│ │ frontend/dockerfile  Step 29/29 : LABEL werf-version=v1.2.13+fix12
│ │ frontend/dockerfile   ---> Running in 0eba0fb1b573
│ │ frontend/dockerfile  Removing intermediate container 0eba0fb1b573
│ │ frontend/dockerfile   ---> b9bbdb91f081
│ │ frontend/dockerfile  Successfully built b9bbdb91f081
│ │ frontend/dockerfile  Successfully tagged c5c02694-3157-4e24-a6f5-e3efddf1fcf5:latest
│ │ ┌ Store stage into .../werf-guide-app
│ │ └ Store stage into .../werf-guide-app (14.95 seconds)
│ ├ Info
│ │      name: .../werf-guide-app:8dd338dab9cf7e58c1aafbd3c99589c68517812054d38d5eca46b69e-1630413035974
│ │        id: b9bbdb91f081
│ │   created: 2021-08-31 15:30:35 +0300 MSK
│ │      size: 9.5 MiB
│ └ Building stage frontend/dockerfile (24.97 seconds)
└ ⛵ image frontend (32.04 seconds)

Release "werf-guide-app" does not exist. Installing it now.

┌ Waiting for release resources to become ready
│ ┌ Status progress
│ │ DEPLOYMENT      REPLICAS  AVAILABLE  UP-TO-DATE
│ │ werf-guide-app  1/1       0          1
│ │ │    POD                         READY  RESTARTS  STATUS    ---
│ │ └──  guide-app-6b89879785-pklns  0/2    0         Init:0/1  Waiting  for:  available  0->1
│ │ STATEFULSET  REPLICAS  READY  UP-TO-DATE
│ │ minio        1/1       0      1
│ │ │    POD  READY  RESTARTS  STATUS             ---
│ │ └──  0    0/1    0         ContainerCreating  Waiting  for:  ready  0->1
│ │ mysql        1/1       1      1
│ │ JOB                        ACTIVE  DURATION  SUCCEEDED/FAILED
│ │ setup-and-migrate-db-rev1  1       3s        0/0
│ │ │    POD                        READY  RESTARTS  STATUS             ---
│ │ └──  and-migrate-db-rev1-jhlh8  0/1    0         ContainerCreating  Waiting  for:  pods  should  be  terminated,  succeeded  0->1
│ │ setup-minio-rev1           1       3s        0/0
│ │ │    POD               READY  RESTARTS  STATUS             ---
│ │ └──  minio-rev1-v72nq  0/1    0         ContainerCreating  Waiting  for:  pods  should  be  terminated,  succeeded  0->1
│ └ Status progress
...
│ ┌ deploy/werf-guide-app po/werf-guide-app-6b89879785-pklns container/wait-db-readiness logs
│ │ rails aborted!
│ │ ActiveRecord::ConnectionNotEstablished: Cant connect to MySQL server on 'mysql' (115)
│ │
│ │ Caused by:
│ │ Mysql2::Error::ConnectionError: Cant connect to MySQL server on 'mysql' (115)
│ │
│ │ Tasks: TOP => db:migrate:status
│ │ (See full trace by running task with --trace)
│ └ deploy/werf-guide-app po/werf-guide-app-6b89879785-pklns container/wait-db-readiness logs
│
│ ┌ job/setup-and-migrate-db-rev1 po/setup-and-migrate-db-rev1-jhlh8 container/setup-and-migrate-db logs
│ │ mysqladmin: connect to server at 'mysql' failed
│ │ error: 'Cant connect to MySQL server on 'mysql' (115)'
│ │ Check that mysqld is running and that the socket: '/var/run/mysqld/mysqld.sock' exists!
│ └ job/setup-and-migrate-db-rev1 po/setup-and-migrate-db-rev1-jhlh8 container/setup-and-migrate-db logs
|
│ ┌ job/setup-and-migrate-db-rev1 po/setup-and-migrate-db-rev1-jhlh8 container/setup-and-migrate-db logs
│ │ mysqladmin: connect to server at 'mysql' failed
│ │ error: 'Access denied for user 'root'@'172.17.0.1' (using password: YES)'
│ └ job/setup-and-migrate-db-rev1 po/setup-and-migrate-db-rev1-jhlh8 container/setup-and-migrate-db logs
│
│ ┌ deploy/werf-guide-app po/werf-guide-app-6b89879785-pklns container/wait-db-readiness logs
│ │ rails aborted!
│ │ ActiveRecord::NoDatabaseError: Unknown database 'werf-guide-app'
│ │
│ │ Caused by:
│ │ Mysql2::Error: Unknown database 'werf-guide-app'
│ │
│ │ Tasks: TOP => db:migrate:status
│ │ (See full trace by running task with --trace)
│ └ deploy/werf-guide-app po/werf-guide-app-6b89879785-pklns container/wait-db-readiness logs
│
│ ┌ job/setup-and-migrate-db-rev1 po/setup-and-migrate-db-rev1-jhlh8 container/setup-and-migrate-db logs
│ │ Created database 'werf-guide-app'
│ └ job/setup-and-migrate-db-rev1 po/setup-and-migrate-db-rev1-jhlh8 container/setup-and-migrate-db logs
│
│ ┌ job/setup-minio-rev1 po/setup-minio-rev1-v72nq container/setup-minio logs
│ │ Added "minio" successfully.
│ │ Bucket created successfully "minio/werf-guide-app".
│ └ job/setup-minio-rev1 po/setup-minio-rev1-v72nq container/setup-minio logs
...
│ ┌ deploy/werf-guide-app po/werf-guide-app-6b89879785-pklns container/wait-db-readiness logs
│ │
│ │ database: werf-guide-app
│ │
│ │  Status   Migration ID    Migration Name
│ │ --------------------------------------------------
│ │    up     20210817162438  Create talkers
│ │    up     20210817164348  Add name to talkers
│ │   down    20210830170827  Create active storage tablesactive storage
│ │   down    20210830171006  Create s3 files
│ │
│ └ deploy/werf-guide-app po/werf-guide-app-6b89879785-pklns container/wait-db-readiness logs
│
│ ┌ Status                     progress
│ │ DEPLOYMENT      REPLICAS  AVAILABLE  UP-TO-DATE
│ │ werf-guide-app  1/1       0->1       1
│ │ │    POD                         READY  RESTARTS  STATUS
│ │ └──  guide-app-6b89879785-pklns  2/2    0         PodInitializing  ->  Running
│ │ STATEFULSET  REPLICAS  READY  UP-TO-DATE
│ │ minio        1/1       1      1
│ │ │    POD  READY  RESTARTS  STATUS
│ │ └──  0    1/1    0         Running
│ │ mysql        1/1       1      1
│ │ JOB                        ACTIVE  DURATION  SUCCEEDED/FAILED
│ │ setup-and-migrate-db-rev1  0       24s       1/0
│ │ │    POD                        READY  RESTARTS  STATUS
│ │ └──  and-migrate-db-rev1-jhlh8  0/1    0         Completed
│ │ setup-minio-rev1           0       25s       1/0
│ │ │    POD               READY  RESTARTS  STATUS
│ │ └──  minio-rev1-v72nq  0/1    0         Completed
│ └ Status                     progress
└ Waiting for release resources to become ready (30.31 seconds)

NAME: werf-guide-app
LAST DEPLOYED: Tue Aug 31 15:30:55 2021
NAMESPACE: werf-guide-app
STATUS: deployed
REVISION: 1
TEST SUITE: None
Running time 65.26 seconds
```

Now let's access the `/download` endpoint to get the file from S3:
```shell
curl http://werf-guide-app/download
```

Since we haven’t uploaded any files yet, we’ll get this:
```
You haven't uploaded anything yet.
```

Now let’s create a new file and upload it to the S3 storage:
<div class="tabs">
<a href="javascript:void(0)" class="tabs__btn tabs__s3__btn active" onclick="openTab(event, 'tabs__s3__btn', 'tabs__s3__content', 'tab__s3__linux_macos')">Linux/macOS</a>
<a href="javascript:void(0)" class="tabs__btn tabs__s3__btn" onclick="openTab(event, 'tabs__s3__btn', 'tabs__s3__content', 'tab__s3__windows')">Windows</a>
</div>
<div id="tab__s3__linux_macos" class="tabs__content tabs__s3__content active" markdown="1">
```shell
echo "This is file content." > file.txt
curl -F "file=@file.txt" http://werf-guide-app/upload
```
</div>
<div id="tab__s3__windows" class="tabs__content tabs__s3__content" markdown="1">
```shell
"This is file content." | Out-File -Encoding ascii -FilePath file.txt
curl.exe -F "file=@file.txt" http://werf-guide-app/upload
```
</div>

The expected output indicates that the file has been successfully added to the storage:
```
File uploaded.
```

Let's try to pull the file from the storage again:
```shell
curl http://werf-guide-app/download
```

You should see the file content:
```
This is file content.
```

Let’s make sure that the file gets saved directly to the storage and pulled from it. To do this, run the container having the `mc` tool to interact with MinIO:
```shell
kubectl run mc --image=minio/mc --rm -it --command -- bash
```

Now, execute the following commands in the container’s shell:
```shell
# Connect to MinIO
mc alias set minio http://minio:9000 minioadmin minioadmin
# Get the content of file stored in S3
mc cat "minio/werf-guide-app/$(mc ls minio/werf-guide-app | awk 'NR==1 {print $5}')"
```

The expected outcome:
```
This is file content.
```

In this chapter, we learned how to store files in the S3-compatible object storage instead of the container file system. With this approach, the application Pods can be created and deleted without issues: files are stored safely, and any application replica can quickly access them. At the same time, the file system on Kubernetes nodes will not be filled with unnecessary files.

Keep in mind that you can only store data you can afford to lose in a container. All other data must be stored in the appropriate database/storage. This approach is endorsed by many, e.g. you can find it in the [best practices](https://cloud.google.com/architecture/best-practices-for-operating-containers#ensure_that_your_containers_are_stateless_and_immutable) by Google Cloud engineers.
