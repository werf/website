## Подготовка stateful-приложения

Сейчас наше приложение не использует БД и не хранит никаких данных (т.е. stateless). Поэтому, чтобы сделать его stateful, нам в первую очередь нужно {% include 200_real_apps/040_db/{{ page.framework_id }}/001_preparing_stateful_app.md.liquid %}

{% include 200_real_apps/040_db/{{ page.framework_id }}/005_major_changes.md.liquid %}

## Добавление endpoints `/remember` и `/say` в приложение

Добавим два новых endpoints, один из которых будет сохранять данные в БД (`/remember`), а второй — доставать их из БД (`/say`).

Наш новый контроллер и модель:

{% include 200_real_apps/040_db/{{ page.framework_id }}/010_new_controllers.md.liquid %}

Добавим новые пути в список маршрутов:

{% include 200_real_apps/040_db/{{ page.framework_id }}/013_list_of_routes.md.liquid %}

{% include 200_real_apps/040_db/{{ page.framework_id }}/015_two_simple_migrations.md.liquid %}

Новые endpoints — `/remember` и `/say` — готовы к работе.

## Развертывание и подключение MySQL

В реальной инфраструктуре базы данных могут быть развернуты как в Kubernetes, так и вне его. Вне Kubernetes базы данных могут развертываться и обслуживаться самостоятельно, либо могут использоваться managed-решения вроде Amazon RDS. Для нашего приложения, в целях демонстрации, мы развернём БД MySQL в Kubernetes с помощью простого StatefulSet:
{% include 200_real_apps/040_db/{{ page.framework_id }}/017_stateful_set.md.liquid %}
>_Вы также можете использовать базы данных, развернутые любым другим способом. В таком случае вам не нужно развертывать вышеупомянутый StatefulSet, все же дальнейшие инструкции остаются без изменений._

Теперь настроим приложение на работу с новой БД:

{% include 200_real_apps/040_db/{{ page.framework_id }}/020_setup_db_work.md.liquid %}


## Инициализация и миграции БД

Есть несколько способов выполнять инициализацию и миграции БД при развертывании приложений в Kubernetes. Мы рассмотрим один простой, но хорошо работающий метод. В нем миграции БД (и, если требуется, инициализация) будут выполняться отдельной Job одновременно с развертыванием приложения и самой БД.

Чтобы выдержать очередность развертывания ресурсов, мы:
1. Требуем от Job, которая выполнит инициализацию/миграции БД, дождаться доступности базы данных перед началом работы.
1. Требуем от приложений перед тем, как запуститься, дождаться доступности базы данных _и_ подготовки базы данных _и_ выполнения миграций.

Таким образом, при деплое все K8s-ресурсы будут созданы одновременно, но начнут работу в следующем порядке:
1. Запустится БД.
1. Затем выполнится Job с инициализацией/миграциями БД.
1. Затем запустятся приложения.

Реализуем это, добавив Job для выполнения миграций/инициализации базы данных:

{% include 200_real_apps/040_db/{{ page.framework_id }}/025_migration_job.md.liquid %}

{% offtopic title="Зачем ждать выполнения 10 подряд успешных проверок доступности БД?" %}
Это предохраняет нас от случая, когда `mysqladmin ping` выполняется только один раз и до того, как StatefulSet с MySQL начнёт перезапускаться при деплое. В таких случаях во время выполнения инициализации/миграций база данных может оказаться недоступна.

Также в образах с БД при первом запуске главный процесс БД может несколько раз перезапускаться (при этом без перезапуска контейнера). В таком случае, если проверять БД на доступность только один раз, то может оказаться, что после успешной однократной проверки запускаются миграции/инициализация в то же время, когда начинает перезапускаться сам процесс БД. От этого нас тоже страхует выполнение `mysqladmin ping` несколько раз подряд.

Количество успешных проверок подряд можно изменять — значение 10 приведено как пример.
{% endofftopic %}

{% include 200_real_apps/040_db/{{ page.framework_id }}/027_init_container.md.liquid %}

## Проверка работы приложения и БД

Развернём приложение:
```shell
werf converge --repo <ИМЯ ПОЛЬЗОВАТЕЛЯ DOCKER HUB>/werf-guide-app
```

Ожидаемый результат:
{% include 200_real_apps/040_db/{{ page.framework_id }}/030_expected_result.md.liquid %}

> Если кажется, что процесс завис, а в сообщениях сплошные ошибки — все нормально, просто идет проверка на состояние MySQL, и нужно немного подождать (обычно не более 1-2 минут).

Попробуем обратиться на `/say`, который должен попытаться достать данные из БД:
```shell
curl http://werf-guide-app.test/say
```

Но так как в базе данных пока пусто, должно вернуться следующее:
```shell
I have nothing to say.
```

Тогда сохраним данные в БД через `/remember`:
```shell
curl "http://werf-guide-app.test/remember?answer=Love+you&name=sweetie"
```

Ожидаемый результат, означающий, что данные сохранены:
```shell
Got it.
```

Снова попробуем получить данные из БД через `/say`:
```shell
curl http://werf-guide-app.test/say
```

Ожидаемый успешный результат:
```shell
Love you, sweetie!
```

Также мы можем убедиться, что данные в базе действительно сохранены, запросив напрямую из БД содержимое таблицы:
{% include 200_real_apps/040_db/{{ page.framework_id }}/033_database_request.md.liquid %}

Ожидаемый результат:
{% include 200_real_apps/040_db/{{ page.framework_id }}/035_expected_result_db.md.liquid %}

Готово!

Итогом этой главы стала реализация stateful-приложения, развертывание базы данных вместе с этим приложением, а также автоматическая инициализация БД и выполнение миграций. Подобный подход должен хорошо работать с любыми реляционными БД.

_Как и прежде, увидеть все сделанные в этой главе изменения вы можете, выполнив команды, описанные [в начале главы](#подготовка-репозитория)._
