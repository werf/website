## Новое приложение на {{ page.framework_name }}

Далее мы будем использовать новое простое приложение на {{ page.framework_name }}, функционально идентичное приложению из предыдущего раздела.

Получили мы его следующим образом — сначала был сгенерирован скелет нового {{ page.framework_name }}-приложения командой:

{% include 200_real_apps/010_basic_app/{{ page.framework_id }}/001_generate_app.md.liquid %}

> **ОБРАТИТЕ ВНИМАНИЕ!** Эту команду и нижеследующие не нужно выполнять, здесь мы просто рассказываем, как получили приложение, которое используется в примере. К выполнению предназначена глава "Деплой нового приложения".

В нём была оставлена конфигурация только для production-окружения и убрано всё, что не требуется на данном этапе.

После этого был добавлен новый путь `/ping` для нашего API:

{% include 200_real_apps/010_basic_app/{{ page.framework_id }}/005_add_ping.md.liquid %}

Этот путь будет обрабатываться методом `ping` стандартного контроллера, возвращающим текст `pong`:

{% include 200_real_apps/010_basic_app/{{ page.framework_id }}/010_return_pong.md.liquid %}

Что касается сборки и CI/CD, то основные изменения затронули сборку образа:
{% include 200_real_apps/010_basic_app/{{ page.framework_id }}/015_building_image.md.liquid %}

… а CI/CD изменилось незначительно. К примеру, так выглядит новый Deployment приложения:
{% include 200_real_apps/010_basic_app/{{ page.framework_id }}/020_new_deployment.md.liquid %}

Приложение — полностью stateless, не требует базы данных для работы. Мы сделаем его stateful и развернём для него базу данных в следующих главах.

## Деплой нового приложения

Проверим работоспособность нового приложения, развернув его в Kubernetes:
```shell
werf converge --repo <ИМЯ ПОЛЬЗОВАТЕЛЯ DOCKER HUB>/werf-guide-app
```

Ожидаемый результат:

{% include 200_real_apps/010_basic_app/{{ page.framework_id }}/025_expected_result.md.liquid %}

Проверим, действительно ли наше приложение работает:
```shell
curl http://werf-guide-app.test/ping
```

Ожидаемый ответ:
```shell
pong
```
