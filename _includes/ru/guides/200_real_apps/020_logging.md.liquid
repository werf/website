## Вывод логов в stdout

У задеплоенных в Kubernetes приложений логи всегда должны отправляться в [stdout/stderr](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8#%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B9_%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4). Отправка логов в стандартные потоки делает логи доступными для Kubernetes и систем сбора логов, помогает избегать потерь логов при пересоздании контейнеров, а также переполнения логами дисков Kubernetes-узлов при сохранении их в файлах внутри контейнеров.

{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/005_default_channel.md.liquid %}

{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/015_direction_logs.md.liquid %}

## Формат логов

Логи {% include guides/200_real_apps/020_logging/{{ page.framework_id }}/017_additional_entity.md.liquid %} {{ page.framework_name }}-приложения по умолчанию представляют собой обычный текст:

{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/020_log_format.md.liquid %}

{% comment %} Text output about the format and complexity of parsing {% endcomment %}

{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/025_log_parsing.md.liquid %} Такой текст парсить системами сбора и анализа логов будет очень непросто.

Эту проблему можно решить, если отдавать логи в структурированном формате вроде JSON: система сбора логов обычно очень просто распознает и разбирает JSON-логи, а также корректно обрабатывает логи/сообщения в неожиданных, неструктурированных форматах, которые могут вклиниваться между логами в JSON-формате.

{% comment %} Activation of JSON log output {% endcomment %}

{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/030_installing_json.md.liquid %}

> _Добавление поддержки тегирования логов выходит за рамки этого руководства, но может быть реализовано при необходимости._

{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/033_default_json.md.liquid %}

> **ОБРАТИТЕ ВНИМАНИЕ!** Эти изменения и нижеследующие не нужно выполнять самим, здесь мы просто рассказываем, как получили приложение, которое используется в примере. К выполнению предназначена глава «Проверка работоспособности».

## Управление уровнем логирования

По умолчанию уровень логирования приложения для production-окружения задан как `{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/035_fr_loglevel.md.liquid %}`. Но иногда возникает необходимость изменить это.

К примеру, при диагностике проблем в production может помочь переключение логирования с `info` на `debug` для получения дополнительной отладочной информации. Но если приложение работает в большом количестве реплик, то переключать все реплики приложения на `debug` может быть не лучшей идеей, т.к. это может сказаться на безопасности, а также сильно увеличить нагрузку на компоненты, ответственные за сбор, хранение и анализ логов.

Решить эту проблему поможет возможность выставлять уровень логирования через переменную окружения. Это позволит, например, запустить рядом с уже существующим Deployment'ом приложения, у которого уровень логирования `info`, точно такой же Deployment, но в одной реплике и с уровнем логирования `debug`. Также для этого нового Deployment'а мы можем отключить централизованный сбор логов, если таковой имеется. Всё это в совокупности позволит нам не перегружать системы сбора логов и не сохранять в них потенциально небезопасные отладочные логи.

Возможность указывать уровень логирования через переменную окружения `{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/036_fr_def_log_var.md.liquid %}` реализуется так:

{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/037_logs_via_variable.md.liquid %}

Если переменная окружения не указана, будет использован стандартный уровень `{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/035_fr_loglevel.md.liquid %}`.

{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/040_filtering_logs.md.liquid %}

## Отображение логов при деплое с werf

По умолчанию werf при деплое показывает логи всех контейнеров приложения и делает это до тех пор, пока они не перейдут в состояние `Ready`. 
С помощью специальных werf-аннотаций можно организовать фильтрацию логов и выводить только те строки, которые удовлетворяют заданным шаблонам.
В дополнение к этому можно настроить вывод логов только для определённых контейнеров.

К примеру, следующим образом можно отключить вывод контейнера с именем `container_name` при выкате:
```yaml
annotations:
  werf.io/skip-logs-for-containers: container_name
```

А в следующем примере показывается, как можно выводить только те строки, которые удовлетворяют заданному регулярному выражению:
```yaml
annotations:
  werf.io/log-regex: ".*ERROR.*"
```

Список всех доступных аннотаций можно посмотреть [здесь]({{ site.url }}/documentation/v1.2/reference/deploy_annotations.html).

> _Эти аннотации влияют только на то, как логи отображаются при деплое с werf. Они не оказывают никакого влияния на развертываемое приложение или его конфигурацию. Логи по-прежнему доступны в stdout/stderr контейнера в первоначальном виде._

## Проверка работоспособности

Теперь попробуем развернуть приложение:
```shell
werf converge --repo <ИМЯ ПОЛЬЗОВАТЕЛЯ DOCKER HUB>/werf-guide-app
```

Ожидаемый результат:

{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/045_expected_result.md.liquid %}


Выполним пару запросов для генерации логов:
```shell
curl http://werf-guide-app.test/ping       # вернёт "pong" и код возврата 200
curl http://werf-guide-app.test/not_found  # ничего не вернёт, только код возврата 404
```

В результате выполнения запросов возвращаемые сервером коды возврата отображаться не будут, но их можно посмотреть в логах. Проверим их:

{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/050_checking_logs.md.liquid %}

Ожидаемый результат:

{% include guides/200_real_apps/020_logging/{{ page.framework_id }}/055_second_expected_result.md.liquid %}

Как видим, логи теперь отдаются в JSON и легко могут быть распарсены. Некоторые логи по-прежнему отдаются обычным текстом, но главное, что системы сбора логов теперь не будут пытаться распарсить логи приложения и часть других логов так, как будто они имеют один формат: JSON-логи сохранятся отдельно и для них будет возможен поиск/фильтрация только по нужным полям.
